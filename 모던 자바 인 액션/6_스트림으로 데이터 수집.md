# 스트림으로 데이터 수집

## 컬렉터란 무엇인가?

Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다. 5장에서는 '각 요소를 리스트로 만들어라'를 의미하는 toList를 Collector 인터페이스의 구현으로 사용했다. 여기서는 groupingBy를 이용해서 '각 키 버킷 그리고 각 키 버킷에 대응하는 요소 리스트를 값으로 포함하는 맵을 만들라'는 동작을 수행한다.  

### 고급 리듀싱 기능을 수행하는 컬렉터

collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다.  
Collector 인터페이스의 메서드를 어떻게 구현하느냐에 따라 스트림에 어떤 리듀싱 연산을 수행할지 결정된다.  
Collector 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다. 예를 들어 가장 많이 사용하는 직관적인 정적 메서드로 toList를 꼽을 수 있다.  

### 미리 정의된 컬렉터

6장에서는 미리 정의된 컬렉터, 즉 groupingBy 같이 Collector 클래스에서 제공하는 팩토리 메서드의 기능을 설명한다.  
Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.  

* 스트림 요소를 하나의 값으로 리듀스하고 요약
* 요소 그룹화
* 요소 분할

<br/>

## 리듀싱과 요약

``long howManyDishes = menu.stream().collect(Collectors.counting());``  
=> ``long howManyDishes = menu.stream().count();`` counting() 이라는 팩토리 메서드가 반환하는 컬렉터를 사용했다.  

이제 본격적으로 미리 정의된 컬렉터를 이용해서 스트림의 최댓값과 최솟값을 찾는 방법을 살펴보자.  

### 스트림값에서 최댓값과 최솟값 검색

메뉴에서 칼로리가 가장 높은 요리를 찾는다고 가정하자. Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다. 두 컬렉터는 스트림의 요소를 비교하는 데 사용할 Comparator를 인수로 받는다.  

```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);

Optional<Dish> mostCalorieDish = menu.stream()
    .collect(maxBy(dishCaloriesComparator));
```

스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용된다.  
이러한 연산을 **요약**연산이라 부른다.  

### 요약 연산

Collectors 클래스는 Collectors.summingInt 라는 특별한 요약 팩토리 메서드를 제공한다.  
summingInt는 객체를 int로 매핑하는 함수를 인수로 받는다. summingInt의 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다. 그리고 summingInt가 collect 메서드로 전달되면 요약 작업을 수행한다. 다음은 메뉴 리스트의 총 칼로리를 계산하는 코드다.  

```java
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
//int totalCalories = menu.stream().mapToInt(Dish::getCalories).sum(); 이것도 됨
```

Collectors.summingLong과 Collectors.summingDouble 메서드는 같은 방식으로 동작하며 각각 long 또는 double 형식의 데이터로 요약한다는 점만 다르다. 이러한 단순 합계 외에 평균값 계산 등의 연산도 요약 기능으로 제공한다. Collectors.averagingInt 같이 말이다.  

```java
Double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));
```

### 문자열 연결

컬렉터에 joining 팩토리 메서드를 이용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다. 즉, 다음은 메뉴의 모든 요리명을 연결하는 코드다.  

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());
```

joining 메서드는 내부적으로 StringBuilder를 이용해서 문자열을 하나로 만든다. 

연결된 두 요소 사이에 구분 문자열을 넣을 수 있도록 오버로드된 joining 팩토리 메서드도 있다.  

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
```

### 범용 리듀싱 요약 연산

지금까지 살펴본 모든 컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다. 즉, 범용 Collectors.reducing으로도 구현할 수 있다.  

```java
int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -> i + j));
```

칼로리 합계를 reducing 메서드로 만들어진 컬렉터로도 계산할 수 있다.  
reducing 인수는 세 개를 받는다.  

* 첫 번째 인수는 리듀싱 연산의 시작값이거나 스트림에 인수가 없을 때는 반환값이다. (숫자 합계에서는 인수가 없을 때 반환값으로 0이 적합하다)
* 두 번째 인수는 요리를 칼로리 정수로 변환할 때 사용한 변환 함수다.
* 세 번째 인수는 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator다. 예제에서는 두 개의 int가 사용되었다.

```java
Optional<Dish> mostCalorieDish = menu.stream().collect(reducing(
    (d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2
));
```

다음과 같이 한 개의 인수를 가질 수도 있다. 첫 번째 인수를 스트림의 첫 번째 요소로 받고, 자신을 그대로 반환하는 **항등 함수**를 두 번째 인수로 받는다. 즉, 한 개의 인수를 갖는 reducing 컬렉터는 시작값이 없으므로 빈 스트림이 넘겨졌을 때 시작갑싱 설정되지 않는 상황이 벌어진다. 그렇기에 한 개의 인수를 갖는 reducing은 Optional<Dish> 객체를 반환한다.  

칼로리를 다 더하는 식을 Integer 클래스의 sum 메서드 참조를 이용하면 좀 더 단순화할 수 있다.  

```java
int totalCalories = menu.stream().collect(reduce(0,
                                                Dish::getCalories,
                                                Integer::sum));
```

컬렉터를 이용하지 않고 map으로 스트림을 변경한 뒤에 리듀싱하는 연산을 5장에서 배웠었다.  
자신의 상황에 맞는 방법을 선택하는 것이 좋다.  

<br/>

## 그룹화

데이터 집합을 하나 이상의 특성으로 분류해서 그룹화하는 연산도 데이터베이스에서 많이 수행되는 작업이다.  
팩토리 메서드 Collectors.groupingBy를 이용해서 쉽게 메뉴를 그룹화할 수 있다.  

```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));
```

스트림의 각 요리에서 Dish.Type과 일치하는 모든 요리를 추출하는 함수를 groupingBy 메서드로 전달했다. 이 함수를 기준으로 스트림이 그룹화되므로 이를 **분류 함수**라고 부른다.  

더 복잡한 분류 기준이 필요한 상황에서는 메서드 참조를 분류 함수로 사용할 수 없다.  
따라서 메서드 참조 대신 람다 표현식으로 필요한 로직을 구현할 수 있다.  

```java
public enum CaloricLevel{DIET, NORMAL, FAT}

Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
    groupingBy(dish -> {
        if (dish.getCalories() <= 400) return CaloricLevel.DIET;
        else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
        else return CaloricLevel.FAT;
    }));
```

다음과 같이 말이다.  

### 그룹화된 요소 조작

요소를 그룹화 한 다음에는 각 결과 그룹의 요소를 조작하는 연산이 필요하다.

예를 들어, 500 칼로리가 넘는 요리만 필터한다고 가정할 때에  

```java
Map<Dish.Type, List<Dish>> caloricDishesByType =
    menu.stream().filter(dish -> dish.getCalories() > 500)
    .collect(groupingBy(Dish::getType));
//{MEAT=[pork, beef], OTHER=[french, pizza]}
```

다음과 같이 표현할 수 있을 것이다. 그러나 해당 코드의 단점이 있다.  바로 FISH 타입이 아예 사라졌다는 것이다.  

Collectors 클래스는 일반적인 분류 함수에 Collector 형식의 두 번째 인수를 갖도록 groupingBy 팩토리 메서드를 오버로드해 이 문제를 해결한다. 두 번째 Collector 안으로 필터 프레디케이트를 이동함으로 이 문제를 해결할 수 있다.  

```java
Map<Dish.Type, List<Dish>> caloricDishesByType = 
    menu.stream().collect(groupingBy(Dish::getType,
            filtering(dish -> dish.getCalories() > 500, toList())));
//{MEAT=[pork, beef], FISH=[], OTHER=[french, pizza]}
```

다음과 같이 출력이 된다.  

```java
Map<Dish.Type, List<String>> dishNamesByType = 
    menu.stream().collect(groupingBy(Dish::getType,
        mapping(Dish::getName, toList())));
```

필터링 대신 mapping을 이용할 수도 있다.  

flatMapping도 있으므로 두 수준의 리스트를 한 수준으로 평면화하기 위해 필요하다면 사용할 수도 있다.  

### 다수준 그룹화

두 인수를 받는 팩토리 메서드 Collectors.groupingBy를 이용해서 항목을 다수준으로 그룹화할 수 있다. Collectors.groupingBy는 일반적인 분류 함수와 컬렉터를 인수로 받는다. 즉, 바깥쪽 groupingBy 메서드에 스트림의 항목을 분류할 두 번째 기준을 정의하는 내부 groupingBy를 전달해서 두 수준으로 스트림의 항목을 그룹화할 수 있다.  

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel = 
    menu.stream().collect(
    groupingBy(Dish::getType,   // 첫 번째 수준의 분류 함수
               groupingBy(dish -> {
                   if (dish.getCalories() < 400)
                       return CaloricLevel.DIET;
                   else if (dish.getCalories() <= 700)
                       return CaloricLevel.NORMAL;
                   else return CaloricLevel.FAT;
               })));
//{MEAT={NORMAL=[beef, chicken], FAT=[pork]}, FISH={NORMAL=[salmon], DIET=[prawns]}, OTHER={NORMAL=[french, pizza], DIET=[rice, season]}}
```

### 서브그룹으로 데이터수집

위에서 두 번째 groupingBy 컬렉터를 외부 컬렉터로 전달해서 다수준 그룹화 연산을 구현했다. 사실 첫 번째 groupingBy로 넘겨주는 컬렉터의 형식은 제한이 없다. 예를 들어 다음 코드처럼 groupingBy 컬렉터에 두 번째 인수로 counting 컬렉터를 전달해서 메뉴에서 요리의 수를 종류별로 계산할 수 있다.  

```java
Map<Dish.Type, Long> typesCount = menu.stream().collect(
    groupingBy(Dish::getType, counting())
);
//{MEAT=3, FISH=2, OTHER=4}
```

``groupingBy(f)``는 사실 ``groupingBy(f, toList())``의 축약형이다.  
요리의 **종류**를 분류하는 컬렉터로 메뉴에서 가장 높은 칼로리를 가진 요리를 찾는 프로그램도 다시 구현할 수 있다.  

```java
Map<Dish.Type, Optional<Dish>> mostCaloricByType = 
    menu.stream()
    .collect(
    groupingBy(Dish::getType,
               maxBy(comparingInt(Dish::getCalories)))
);
//{OTHER=Optional[pizza], MEAT=Optional[pork], FISH=Optional[salmon]}

Optional<Dish> mostCalorieDish = 
    menu.stream()
    .collect(maxBy(dishCaloriesComparator));
//Optional[pork]
```

> 메뉴의 요리 중 Optional.empty()를 값으로 갖는 요리는 존재하지 않는다. 처음부터 존재하지 않는 요리의 키는 맵에 추가되지 않기 때문이다. groupingBy 컬렉터는 스트림의 첫 번째 요소를 찾은 이후에야 그룹화 맵에 새로운 키를 추가한다. 리듀싱 컬렉터가 반환하는 형식을 사용하는 상황이므로 굳이 Optional 래퍼를 사용할 필요가 없다.

마지막 그룹화 연산에서 맵의 모든 값을 Optional로 감쌀 필요가 없으므로 Optional을 삭제할 수 있다.  
``Collectors.collectingAndThen``으로 컬렉터가 반환한 결과를 다른 형식으로 활용할 수 있다.  

```java
Map<Dish.Type, Dish> mostCaloricByType2 = 
    menu.stream()
    .collect(groupingBy(Dish::getType,
                        collectingAndThen(
                            maxBy(comparingInt(Dish::getCalories)),
                            Optional::get
                        )));
// {MEAT=pork, OTHER=pizza, FISH=salmon}
```

팩토리 메서드 collectingAndThen은 적용할 컬렉터와 변환 함수를 인수로 받아 다른 컬렉터를 반환한다. 반환되는 컬렉터는 기존 컬렉터의 래퍼 역할을 하며 collect의 마지막 과정에서 변환 함수로 자신이 반환하는 값을 매핑한다. 이 예제에서는 maxBy로 만들어진 컬렉터가 감싸지는 컬렉터며 변환 함수 Optional::get 으로 반환된 Optional에 포함된 값을 추출한다.  

```java
Map<Dish.Type, Integer> totalCaloriesByType =
    menu.stream().collect(groupingBy(Dish::getType,
                                     summingInt(Dish::getCalories)));
// {MEAT=1900, FISH=750, OTHER=1550}
```

다음과 같이 사용할 수도 있다.  mapping 과도 합칠 수 있다.  

```java
Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByType =
    menu.stream().collect(
    groupingBy(Dish::getType, mapping(dish -> {
        if (dish.getCalories() <= 400) return CaloricLevel.DIET;
        else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
        else return CaloricLevel.FAT;
    }, toSet())));
// {MEAT=[NORMAL, DIET, FAT], FISH=[NORMAL, DIET], OTHER=[NORMAL, DIET]}
```

Set의 형식이 정해지지 않았는데 ``toCollection``을 이용하면 원하는 방식으로 결과를 제어할 수 있다.  
예로들어, ``toSet()``을 ``toCollection(HashSet::new)`` 로 변경하면 HashSet으로 정해진 것이다.  

<br/>

## 분할

분할은 **분할 함수**라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다. 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Boolean이다. 결과적으로 그룹화 맵은 최대 (참 아니면 거짓의 값을 갖는) 두 개의 그룹으로 분류된다.  
예를 들어 채식주의자 친구를 저녁에 초대했다고 가정하고 요리를 채식 요리와 채식이 아닌 요리로 분류해야 한다.  

```java
Map<Boolean, List<Dish>> partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));
//{false=[pork, beef, chicken, prawns, salmon], true=[french, rice, season, pizza]}
```

이제 ``partitionedMenu.get(true)``로 채식 요리만 얻을 수 있을 것이다. 물론 메뉴 리스트로 생성한 스트림을 프레디케이트로 필터링한 다음에 별도의 리스트에 결과를 수집해도 같은 결과를 얻을 수 있다.  

```java
List<Dish> vegetarianDishes = menu.stream().filter(Dish::isVegetarian).collect(toList());
```

### 분할의 장점

분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.  
컬렉터를 두 번째 인수로 전달할 수 있는 오버로드된 버전의 partitioningBy 메서드도 있다.  

```java
Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType =
    menu.stream().collect(
    partitioningBy(Dish::isVegetarian,
                   groupingBy(Dish::getType)));
// {false={MEAT=[pork, beef, chicken], FISH=[prawns, salmon]}, true={OTHER=[french, rice, season, pizza]}}
```

결과를 보면 채식 요리의 스트림과 채식이 아닌 요리의 스트림을 각각 요리 종류로 그룹화해서 두 수준의 맵이 반환되었다.  
또한 이전 코드를 활용하면 채식 요리와 채식이 아닌 요리 각각의 그룹에서 가장 칼로리가 높은 요리도 찾을 수 있다.  

```java
Map<Boolean, Dish> collect4 = menu.stream().collect(
    partitioningBy(Dish::isVegetarian,
                   collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get)));
// {false=pork, true=pizza}
```

### 숫자를 소수와 비소수로 분할하기

정수 n을 인수로 받아서 2에서 n까지의 자연수를 소수와 비소수로 나누는 프로그램을 구현해보자.  
먼저 주어진 수가 소수인지 아닌지 판단하는 프레디케이트를 구현하면 편리할 것이다.  

```java
public static boolean isPrime(int candidate) {
    int candidate = (int) Math.sqrt((double)candidate);
    return IntStream.range(2, candidate).noneMatch(i -> candidate % i == 0);
}
```

다음과 같이 구현하였다.  

```java
public static Map<Boolean, List<Integer>> partitionPrimes(int n) {
    return IntStream.rangeClosed(2, n).boxed()	//boxed 메서드는 숫자 특화 스트림을 원형 스트림으로 박싱해주는 메서드
        .collect(
        partitioningBy(클래스명::isPrime)
    );
}
```

| 팩토리 메서드     | 반환 형식             | 사용 예제                                                    |
| ----------------- | --------------------- | ------------------------------------------------------------ |
| toList            | List<T>               | 스트림의 모든 항목을 리스트로 수집<br />ex) List<Dish> dishes = menuStream.collect(toList()); |
| toSet             | Set<T>                | 스트림의 모든 항목을 중복이 없는 집합으로 수집<br />ex) Set<Dish> dishes = menuStream.collect(toSet()); |
| toCollection      | Collection<T>         | 스트림의 모든 항목을 발행자가 제공하는 컬렉션으로 수집<br />ex) Collection<Dish> dishes = menuStream.collect(toCollection(), ArrayList::new); |
| counting          | Long                  | 스트림의 항목 수 계산<br />ex) long howManyDishes = menuStream.collect(counting()); |
| summingInt        | Integer               | 스트림의 항목에서 정수 프로퍼티값을 더함<br />ex) int totalCalories = menuStream.collect(summingInt(Dish::getCalories)); |
| averagingInt      | Double                | 스트림 항목의 정수 프로퍼티의 평균값 계산<br />ex) double avgCalories = menuStream.collect(averagingInt(Dish::getCalories)); |
| summarizingInt    | IntSummaryStatistics  | 스트림 내 항목의 최댓값, 최솟값, 합계, 평균 등의 정수 정보 통계 수집<br />ex) IntSummaryStatistics menuStatistics = <br />menuStream.collect(summarizingInt(Dish::getCalories)); |
| joining           | String                | 스트림의 각 항목에 toString 메서드를 호출한 결과 문자열 연결<br />ex) String shortMenu = menuStream.map(Dish::getName).collect(joining(", ")); |
| maxBy             | Optional<T>           | 주어진 비교자를 이용해서 스트림의 최댓값 요소를 Optional로 감싼 값을 반환. <br />스트림에 요소가 없을 때는 Optional.empty() 반환<br />ex) Optional<Dish> fattest =<br /> menuStream.collect(maxBy(comparingInt(Dish::getCalories))); |
| minBy             | Optional<T>           | 주어진 비교자를 이용해서 스트림의 최솟값 요소를 Optional로 감싼 값을 반환.<br /> 스트림에 요소가 없을 때는 Optional.empty() 반환<br />ex) Optional<Dish> lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories))); |
| reducing          | 오퍼레이션에 따름     | 누적자를 초깃값으로 설정한 다음에 BinaryOperator로 스트림의 각 요소를 반복적으로 누적자와 합쳐 스트림을 하나의 값으로 리듀싱<br />ex) int totalCalories = <br />menuStream.collect(reducing(0, Dish::getCalories, Integer::sum)); |
| collectingAndThen | 변환 함수에 따름      | 다른 컬렉터로 감싸고 그 결과에 변환 함수 적용<br />ex) int howManyDishes=<br />menuStream.collect(collectingAndThen(toList(), List::size)); |
| groupingBy        | Map<K, List<T>>       | 하나의 프로퍼티값을 기준으로 스트림의 항목을 그룹화하며 기준 프로퍼티값을 결과 맵의 키로 사용<br />ex) Map<Dish.Type, List<Dish>> dishesByType =<br />menuStream.collect(groupingBy(Dish::getType)); |
| partitioningBy    | Map<Boolean, List<T>> | 프레디케이트를 스트림의 각 항목에 적용한 결과로 항목 분할<br />ex) Map<Boolean, List<Dish>> vegetarianDishes =<br />menuStream.collect(partitioningBy(Dish::isVegetarian)); |

<br/>

## Collector 인터페이스

Collector 인터페이스는 리듀싱 연산을 어떻게 구현할지 제공하는 메서드 집합으로 구성된다.  
이번에는 Collector 인터페이스를 직접 구현해서 더 효율적으로 문제를 해결하는 컬렉터를 만드는 방법을 살펴본다.  

```java
public interface Collector<T, A, R> {
    Supplier<A> supplier();
    BiConsumer<A, T> accumulator();
    Function<A, R> finisher();
    BinaryOperator<A> combiner();
    Set<Characteristics> characteristics();
}
```

위의 코드는 Collector 인터페이스의 시그니처와 다섯 개의 메서드 정의이다.  

* T는 수집될 스트림 항목의 제네릭 형식이다.
* A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다.
* R은 수집 연산 결과 객체의 형식(항상 그런 것은 아니지만 대개 컬렉션 형식) 이다.

예를 들어 Stream<T>의 모든 요소를 List<T>로 수집하는 ToListCollector<T>라는 클래스를 구현할 때,  
``public class ToListCollector<T> implements Collector<T, List<T>, List<T>>`` 로 구현 가능하겠다.  

### Collector 인터페이스의 메서드 살펴보기

#### supplier 메서드 : 새로운 결과 컨테이너 만들기

supplier 메서드는 빈 결과로 이루어진 Supplier를 반환해야 한다. 즉, supplier는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다. ToListCollector 처럼 누적자를 반환하는 컬렉터에서는 빈 누적자가 비어있는 스트림의 수집 과정의 결과가 될 수 있다.  
ToListCollector에서 supplier는 다음처럼 빈 리스트를 반환한다.  

```java
public Supplier<List<T>> supplier() {
    return () -> new ArrayList<T>();
    // return ArrayList::new; 로도 가능
}
```

#### accumulator 메서드 : 결과 컨테이너에 요소 추가하기

