# 지식 탐구

소프트웨어 전문가와 PCB 기술자는 서로가 사용하는 기술의 명칭도 다르고 표기법도 다르다. 하지만, 서로 머리를 맞대어서 완성해낸 프로토타입은 
도메인 전문가가 보았을 때, 동작하는 소프트웨어와 모델 간의 관계를 명확하게 이해할 수 있었다. 효과적인 모델링을 위해 다음의 활동을 했다.  

### 효과적인 모델링의 요소

**1. 모델과 구현의 연계**
초기 프로토타입을 토대로 본질적인 연결 고리를 만든 다음, 이후의 모든 반복 주기 내내 이 연결 고리를 유지함  
ex) 네트에서 도선을 이용해 컴포넌트를 연결해 전기적인 신호를 전달해준 것  
  
**2. 모델을 기반으로 하는 언어 정제**  
초기에는 서로가 사용하고 알고 있는 단어들이 달랐지만, 점차 해석 없이도 문장을 이해할 수 있는 용어로 모델의 구조와 일관되게 문장 구성이 가능해짐  

**3. 풍부한 지식이 담긴 모델 개발**  
객체가 행위를 지니고 규칙을 이행함. 모델은 복잡한 문제를 해결하기 위해 필수불가결함  

**4. 모델의 정제**  
불필요한 개념이 모두 제거되고 본질적인 개념만 식별할 수 있는 모델이 됨  

**5. 브레인스토밍과 실험**  
브레인스토밍을 하여 수 많은 테스트를 해보고, 평가함  
***
### 지식 탐구

도메인 모델링을 수행하는 사람들은 지식을 면밀히 탐구해 엄청난 양의 정보 속에서 미미한 관련성을 찾아낸다. 이 과정속에서 수많은 모델이 시도, 거부, 변형이 된다.
  
과거의 폭포수 개발 방식에서는 분석가가 업무 전문가의 설명을 통해 추상화한 소프트웨어를 프로그래머에게 넘기는 방법이었는데, 이러한 접근법은 피드백이 없어
실패하기 마련이었다. 이 모델에서는 업무 전문가가 알려주는 사항에만 근거했기 때문에 분석가들은 프로그래머와 초기 버전의 소프트웨어에서 경험을 샇을 기회를
얻지 못해서 지식이 축적되지 않는다.  

다른 프로젝트에서는 반복 프로세스를 활용하지만 추상화를 하지않아 지식이 축적되는데 실패한다. 개발자들이 전문가가 원하는 기능을 구현하고 그 다음 일을 묻는 식으로
하게되면 프로그래머가 리팩토링을 하면서 개발하면서 소프트웨어의 말끔한 확장이 가능하겠지만, 프로그래머가 도메인에 관심이 없다면 그 이면에 숨겨진 
원리는 알지 못한 채 애플리케이션에서 수행해야 할 사항만 습득한다. 이 결과 유용한 소프트웨어는 만들 수 있지만, 강력한 기능이 나타나는 정도의 수준에는
도달하지 못하게된다.  

훌륭한 프로그래머라면 시작부터 추상화를 사용해 모델을 발전시킨다.이 과정에서 도메인 전문가와의 협업이 없이 기술적인 측면에서만 일어난다면
개념은 초보적인 수준에 머무를 것이다.  
모든 구성원이 함께 모델을 만들어 나가게 되면 과정을 거치면서 유능한 지식 탐구자로 거듭나게 되고, 도메인 전문가들은 프로젝트에서 요구하는 개념적 엄밀함을 이해하게 된다.
프로그래머와 분석가 모두 모델을 만들어 나가므로 모델은 명료하게 조직화되고 추상화될 수 있고, 구현을 더 용이하게 만들어준다.  

모델은 점점 향상되면서 프로젝트 내의 정보들을 조직화되는 도구가 되며 프로그래밍과 설계와 밀접한 관계를 맺는다.  
모델은 도메인을 이해하는데 실용적이고 유용해야 하며, 쉽게 구현하고 이해하기에 충분할 만큼 엄밀해야 한다.  
***
### 지속적인 학습
소프트웨어를 작성하기 시작할 때 우리는 충분히 알지 못한 상태에서 시작한다.  

생산성이 매우 뛰어난 팀은 **지속적인 학습**을 바탕으로 의식적으로 지식을 함양한다.  

앞의 소프트웨어 전문가와 PCB 기술자의 예에서 알 수 있듯이 무엇보다 중요한 것은 
팀 구성원이나 개발자, 도메인 전문가에게서 똑같이 지식을 얻고 의사소통 체계를 공유하고, 구현을 거쳐 피드백 고리를 완성하는 일을 모두 효과적으로
수행하는 지식 탐구 프로세스를 궤도에 올린 것이다.  
***
### 풍부한 지식이 담긴 설계
도메인에는 다양한 범주의 개념이 존재한다. 지식 탐구는 이러한 통찰력을 반영하는 모델을 만들어낸다.  
개발자는 모델의 변경에 맞춰 구현을 리팩토링해서 모델의 변경된 사항을 표현하고, 애플리케이션에서는 그러한 지식을 활용한다.  

예약어플리케이션의 책임이 각 Cargo를 하나의 Voyage와 연관관계를 맺고, 이것을 기록/관리 하는 것이라고 해보자.  
```java
public int makeBooking(Cargo cargo, Voyage voyage){
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```
다음과 같은 메서드가 있는데, 요구사항 문서에 ``10% 초과예약 허용``이라는 요구사항이 적혀져 있으면 다음과 같이 고칠 수 있을 것이다.  
```java
public int makeBooking(Cargo cargo, Voyage, voyage){
    double maxBooking = voyage.capacity()*1.1;
    if((voyage.bookedCargoSize() + cargo.size()) > maxBooking) return -1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```
그런데 해당 코드는 문제가 있다.  
1. 코드가 작성된 대로라면 개발자의 도움이 있더라도 업무 전문가가 이 코드를 읽고 규칙을 검증하지는 못할 것이다.
2. 해당 업무에 종사하지 않고 기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부시키기가 어려울 것이다.  

요구사항과 같이 초과예약 규칙은 일종의 정책인데, 보통 정책은 각종 규칙을 대체할 필요성 때문에 만들어지니 현재 1개의 요구사항을 가진 현재로서는,  
필요하지 않다. 그러나 담고자 하는 개념은 정책이라는 의미와 잘 맞아 떨어지므로 정책도 똑같이 도메인 주도설계의 중요한 동기에 해당한다.  

```java
public int makeBooking(Cargo cargo, Voyage voyage){
    if(!overbookingPolicy.isAllowed(cargo, voyage)) return -1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}

public boolean isAllowed(Cargo cargo, Voyage voyage){
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
}
```
다음과 같이 표현하면 초과예약이 별개의 정책이라는 사실을 모든 이가 분명히 알 수 있다.  
이런 명시적인 설계는  
1. 모든 이가 초과예약의 특성을 단순히 불분명한 계산에 불과한 것이 아니라 별개의 중요한 업무 규칙임을 알 수 있다.
2. 프로그래머는 업무 전문가에게 그들이 이해할 수 있는 수준에서 기술적 산출물과 코드를 보여줄 수 있고 피드백을 받을 수가 있게된다.

***
### 심층 모델
도메인과 애플리케이션의 요구사항을 이해하게 되면서 대체로 처음에 중요하게 생각했던 피상적인 모델 요소를 버리거나 관점을 바꾼다.  
이것은 처음에는 나타나기 힘들지만 문제의 핵심을 관통하는 포착하기 힘든 추상화가 나타나기 시작한다.  

이 책에서는 위의 예제에서 본 것 처럼 해운 시스템에 기반을 둔다.  
이 프로젝트에서는 화물을 예약하는 행위로 선적이 시작되므로 화물, 운송일정 등을 설명해줄 수 있는 모델을 만들었으나  
이 모든 작업이 모두 필요하고 유용함에도 불구하고 도메인 전문가는 만족스러워하지 않았다고 한다.  

몇 달간 지식 탐구를 하니 해당 하역 작업, 장소 간 이동 등은 하도급자나 회사의 운영팀에서 수행한다는 것을 알게 됐고,  
해운 전문가의 관점에서는 각 주체 사이의 책임 이동이 존재했다고 한다.  
해운업자에서 일부 지역 운송업자로, 한 운송업자에서 다른 운송업자로, 그리고 화물 인수자로 말이다.  

해운 업무를 바라보는 시각이 장소 간 컨테이너의 이동에서 엔티티와 엔티티 사이의 화물에 대한 책임 이동으로 바뀐 것이다.  
즉, 책임 이동을 취급하는 것이 작업과 책임 간의 중요한 관계를 토대로 만들어진 모델의 중심에 자리잡게 되었다.  

이번 장 요약  
- 지속적인 지식 탐구를 통해서 모델을 다듬어라



***






# 의사소통과 언어 사용
모델은 사람들의 머릿속에 축적된 개념을 모은 것으로 도메인에 대한 통찰력을 반영하는 용어와 관계로 표현된다.  
이러한 용어와 상호관계는 기술적인 개발을 할 수 있을 만큼 충분히 정확한 동시에 도메인에 맞게 조정된 언어의 의미체계를 제공한다.  

모델 기반의 의사소통은 한 가지에 한정되어서는 안되고 모든 의사소통 수단에 스며들어야 한다.  
이렇게 되면 약식 다이어그램과 형식에 얽매이지 않는 의사소통을 비롯해 텍스트 문서의 유용성도 향상된다.  

유연하고 풍부한 지식이 담긴 설계를 만들려면 다용도로 사용할 수 있는 팀의 공유 언어와 그 언어에 대한 활발할 실험이 필요하다.  

도메인 전문가는 개발에 관한 용어를 이해하는데에 한계가 있고 본인의 분야 용어는 다양하게 사용할 것이다. 개발자도 마찬가지다.  
이러한 상황에서 도메인 전문가가 원하는 바를 모호하게 설명하면, 개발자도 모호하게 이해할 것이다. 오직 소수만 둘의 언어를 알아들을 것이다.  
서로가 서로의 언어를 번역을 하게 될텐데, 이는 해로운 코드 리팩토링으로 이어진다.  

프로젝트에서 사용하는 언어가 분열되면 일상 토론에서 쓰이는 용어가 프로젝트 산출물에 녹아든 용어와 단절된다.  
같은 사람인데도 말할 때나 글을 쓸 때 서로 다른 용어를 쓰게되고 간결한 표현이 나타나도 코드나 문서에 담기지 않게되기도 한다.  
번역은 의사소통을 무디게 하고,해당 언어는 공통 언어가 될 수 없다.  

UBIQUITOUS 언어에는 클래스와 주요한 연산의 이름이 있고,모델의 관계는 모든 언어에 내재된 결합 규칙이 된다.  
 단어와 구절은 모델을 구성하는 개별 요소의 의미를 각각 반영하게 된다.  
 모델 기반 언어는 개발자 사이에서 시스템의 산출물뿐 아니라 업무와 기능을 기술할 때도 사용해야 한다.  
 
 초기 모델은 이러한 역할을 다하지 못할 것이고, 그렇다고 전문용어를 쓰자니 모호한 설명과 이해의 결과를 낳을 것이다.  
 
 쓸모 있는 모델을 만들어 내는 지식 탐구 과정은 팀 전체가 모델 기반 언어에 헌신할 때 가능해진다.  
 UBUIQUITOUS 언어를 지속적으로 사용하다 보면 모델의 취약점이 드러난다.  
 언어의 공백이 발견되면 토론하여 새로운 단어가 나타나고, 이러한 **언어의 변화는 도메인 모델의 변화로 인식**된다.  
 
 도메인 전문가가 더 넓게 설명하면서 언어의 범위를 넘어가게 될 것이고, 이러한 모든 상황에서 모델 기반 언어를 사용하고 자연스럽게 느껴질 때 까지
 노력한다면 간결한 요소로 복잡한 아이디어를 표현할 수 있는 완전하고 이해하기 쉬운 모델을 만들어 낼 수 있다.  
 
 **모델을 언어의 근간으로 사용하라. 대안 모델을 반영하는 대안이 되는 표현을 시도해보고 새로운 모델에 맞는 클래스, 메서드, 모듈의 이름을  
 지으면서 코드를 리팩토링하라. 언어의 변화가 곧 모델의 변화이고, 도메인 전문가는 도메인 이해에 부자연스럽고 부정확한 용어나 구조에 반대해야하며  
 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾는데에 집중해야 한다.**  
 
 EX P.28 ~ 30  두 개의 시나리오 대화에서 모두 ``운항일정``에 대한 내용이 있으나 시나리오2 에서는 ``운항일정``에 대한 객체가 존재한다.  
 그리고, 항로 설정 명세에 대한 대화에서도 시나리오2 에는 객체가 존재하기에 명확하게 표현이 가능했다.  
 ***
 ### 크게 소리내어 모델링하기
 모델을 정제하는 가장 좋은 방법은 가능한 모델 변형을 구성하는 다양한 요소를 큰소리로 말하면서 살펴보는 것이라고 함  
> RoutingService에 출발지, 목적지, 도착 시각을 전달하면 화물이 멈춰야 할 지점을 찾고, 그것을 데이터베이스에 삽입한다 (모호하고 기술적)
> 출발지, 목적지 등등을 모두 RoutingService에 넣으면 필요한 것이 모두 담긴 Itinerary를 돌려받는다 (아직 장황함)  
> RoutingService는 Route Specification을 만족하는 Itinerary를 찾는다 (간결함)

한 마디로 말하자면, 언어 능력을 활용해서 단어와 구절을 곱씹어보고 표현해야 할 것을 더 쉽게 말하는 방법을 찾아내라는 뜻이다.  
***
### 한 팀, 한 언어
모델의 핵심은 도메인 전문가의 관심을 끌어야 하고, 수준 높은 도메인 전문가도 해당 모델을 이해하지 못한다면 모델에 이상이 있는 것이다.  

사용자가 개발자와 함께 공유할 모델을 찾는 과정이 시작되면 새로운 언어가 발전해감에 따라 도메인 전문가는 해당 언어를 채택하고 기존 문서를 
개정하는 데 각별한 노력을 기울여야 한다. 도메인 전문가가 개발자와 논의하게 되면 언어가 적합하지 않는 부분을 발견하게 되고 모델 기반 언어의 정밀함을
토대로 도메인 전문가가 생각하는 바 중에서 모순되거나 모호한 부분도 알게 된다.  
도메인 전문가는 모델의 언어를 바탕으로 유스케이스를 작성하고 인수 테스트(실제 운영환경에서 사용할 준비가 됐는지 확인하는 테스트)를 구체화함으로써
모델을 훨씬 더 직접적으로 다룰 수 있다.  
***
### 문서와 다이어그램
다이어그램은 의사소통과 설명의 수단이며 다이어그램이 최소화됐을 때 가장 잘 드러난다.  
객체 모델을 전부 포괄하는 다이어그램은 의사소통과는 동떨어지며 세부사항으로 압도할 뿐 다이어그램의 의미가 누락된다.  
다이어그램의 목적은 모델을 잘 전달하고 설명하는데에 있고, 코드는 설계의 세부사항에 대한 저장소 역할이다.  
다이어그램은 모델이나 설계를 완벽하게 표현해야 한다는 강박에 빠져들면 안된다.  

코드가 개념을 직관적으로 구현하는 데 충분하지 않으면 문서를 가지고 설계 의도를 명확하게 나타낼 수 있다.  
문서는 프로젝트와 연관이 있어야 하며 문서에서 설명된 용어가 대호와 코드에 나타나지 않는다면 문서로서의 목적을 수행하지 못하고 있는 것이다.  
문서는 UBIQUITOUS 언어에 영향을 주고 있어야 한다.  
문서를 최소한으로 유지하고 코드와 대화를 보완하는 데 집중함으로써 문서는 프로젝트와 연관된 상태로 유지할 수 있다.  
**UBIQUITOUS 언어와 그것의 발전이 문서를 유효한 상태로 유지하고 프로젝트 활도오가 결부되게 만드는 구심점으로 삼아야한다.**  
***
### 설명을 위한 모델
하나의 모델이 구현, 설계, 의사소통의 기초가 돼야하고, 각 목적에 각기 다른 모델을 갖추는 것은 바람직하지 않다.  
설계를 주도하는 모델은 도메인을 바라보는 하나의 관점에 해당하지만 도메인의 일반 지식을 전달하기 위해 교육적인 도구로만 사용되어
다른 관점을 견지하는 것을 익히는 데 도움을 줄 수 있다. 이러한 목적으로 사람들은 설계와는 무관한 다른 종류의 모델을 전달하는 그림이나
단어를 활용할 수 있다.  
기술적 모델은 기능 수행에 필요한 최소한의 수준으로 범위를 줄여야 하지만, 설명을 위한 모델은 도메인의 여러 측면을 포함할 수 있고,  
이것은 더욱 좁은 범위의 모델을 명확하게 하는 맥락을 제공해준다.  

설명을 위한 모델에서는 의사소통 방식을 마음껏 만들어 낼 수 있으며, 객체 모델일 필요도 없다.  

P.43에 설명을 위한 모델이 예시로 나와있는데, 좌측의 다이어그램만으로는 이해가 어려운 내용을 설명 모델과 함께하면 이해가 쉬워진다.  

이번 장 요약  
- UBIQUITOUS한 언어를 만들어 나가면서 모델을 다듬고, 문서를 통해 코드와 말을 보완하고, 설명 모델을 두어 모델 다이어그램 이해를 쉽게하자.